/* Headers */
NAME     mmu_dbi_rst38;
PARTNO   00;
DATE     2/24/2026;
REVISION 01;
DESIGNER AESilky;
COMPANY  None;
ASSEMBLY None;
LOCATION ;
Device   f1508isptqfp100; /* ATF1504AS 100TQFP ISP/JTAG */

/**
 * ZID (Z80 In-circuit Debugger) Main Logic
 *
 *  - Reset Control including Z80 'Special-Reset' generation
 *  - Memory Management Unit
 *  - Port (I/O) Decode
 *  - Double-Byte Instruction
 *  - RST38 Detect
 *  - Break #1 Control
 *  - Break Detect
 *
 *
 * ==========
 * Reset Control
 * ----------
 * (This will evolve into the Z80 'Special-Reset' generation as well)
 * Generates an internal Init-Reset when the reset input pin is active for
 * 3 CPU clock cycles. It then keeps the Init-Reset true as long as the CPU
 * reset remains active. Init-Reset going false can be used as a clock for
 * synchronous initialization of registers (if needed), as the Z80 CPU takes
 * 2 T-cycles after reset goes inactive before it starts/resumes operation.
 *
 * ==========
 * MMU
 * ----------
 * Treats the 16-bit/64KB memory space as 4 16KB blocks. It treats the ROM
 * and RAM as 16 16KB regions (8 ROM and 8 RAM, 256KB total, 128KB each). 
 * Using 4 registers of 4-bits each*, it maps a ROM or RAM region to a memory
 * block. Regions 0-7 are ROM and regions 8-15 are RAM.
 *
 * Using the mapping, it generates a ROM_SEL or RAM_SEL and the RomRam A14..16
 * address signals (addressing the 128KB space in each device). Additionally,
 * if there is a write to a block that is mapped to a ROM region, it selects
 * the corresponding RAM region for the write operation. Thereby allowing the
 * ROM data to be copied to the RAM simply by reading a ROM location and
 * writing back to the same location.
 *
 * At power-up and hard-reset it initializes the mapping to ROM regions 0, 1,
 * 2, and 3.
 *
 * When the ROM is selected for a read operation a wait-state is generated.
 *
 * *NOTE: Register 4 contains a 5th bit that can be written/read, but is not
 *      used in the mapping. The intended purpose of this bit is to allow the
 *      debug-monitor code to determine if it has been initialized or not. The
 *      Master-Reset clears this bit. Therefore, when the debug-monitor is
 *      running (from address 0000) it can check the bit to see if it has
 *      already initialized, and this is a RST0 or a Special-Reset, or if this
 *      is a Boot, and it needs to initialize. Once it is initialized, it can
 *      set the bit to 1. Other code that writes the mapping needs to retain
 *      the state of the bit to avoid the debug-monitor from re-initializing,
 *      but that is better than the debug-monitor not knowing, and trying to
 *      figure it out some other way.
 *      Mapping register 3 was used, as it is (probably) the least likely to
 *      be changed during normal operation of the system.
 *
 * ==========
 * I/O Port Decode
 * ----------
 * The board uses a number of I/O devices. Some are internal to this
 * component, while some are external. There isn't currently a plan to support
 * added devices, but just in case, half of the I/O space will be reserved
 * decoded and not used. If pins are available, an 'extern_io' signal might
 * be provided.
 *
 * The defined devices and number of addresses needed are:
 * 1. Board Control (2). We need 10 (possibly more) control bits.
 * 2. MMU Select (1). The MMU has 4 registers, but the upper address is used
 *      to select the register while writing/reading a single port.
 * 3. Target-Go (1). This only uses an access (any op) to start the countdown
 *      to transfer to the target system.
 * 4. PC Read (1 (maybe 2)). This is used to read the Program Counter value
 *      that is saved. The thought is to use a shift register and read it
 *      using 16 reads. But, if it ends up being captured in this device it
 *      could be easier to read it with two 8-bit reads.
 * 5. RP2040-Module (4). The Module is used for all communication, access to a
 *      EEPROM for saving configuration, and possibly other functions.
 * 6. Break Address CLK (1). This is used to clock a data bit to the Break
 *      Address shift registers.
 * 7. Break Address Enable CLK (1). This is used to clock a data bit to the
 *      Break Enable shift registers.
 * 8. Break Address Enable Read. Same as 7. but to read the Enable bit back.
 * 9. Break Address Enable Clear (1). Any operation to this port clears the
 *      Break Enable shift registers to 0.
 *
 * To minimize the number of bits used to decode the device ports, 16 ports
 * are allocated to each device. This still reserves 128 port addresses for
 * use by external devices..
 *
 * Port Allocations:
 *      00..0F: Board/Break Control (internal)
 *      10..1F: MMU Select (internal)
 *      20..2F: PC Read (internal)
 *      30..3F: Target-Go
 *      40..4F: RP2040-Module
 *      50..5F: Break Address CLK
 *      60..6F: Break Address Enable CLK
 *      70..7F: Break Address Enable CLR
 *      80..FF: Reserved for External Devices
 *
 *      
 * ==========
 * DBI Detect
 * ----------
 * Monitors the data bus during instruction fetches for a sequence two
 * instruction fetches of:
 * - CB nn (extended logical operations)
 * - DD nn (IX operations)
 * - ED nn (extended Z80 operations (16-bit, Interrupt, Memory/IO, etc.))
 * - FD nn (IY operations)
 *
 * When the first instruction fetch is detected the DBI signal is set. It
 * remains set until the following instruction fetch is completed.
 *
 * ==========
 * RST38 Detect
 * ----------
 * Monitors the data bus during instruction fetches for a data of 0xFF. When
 * this instruction fetch is detected the RST38 signal is set. It remains set
 * until the instruction fetch is completed.
 *
 * ==========
 * Local NMI generation
 * ----------
 * NMI to the local Z80 is gated from the target such that a target NMI is only
 * passed through when in Target Mode (running the target), not when running
 * the debugger. The target NMI is also blocked when doing a single bus operation
 * on the target (memory or port read/write).
 *
 * Additionally, NMI is used for an attention request from the RP2040 Module
 * when already in debug mode (not target mode) rather than generating a
 * special reset.
 * 
 * ==========
 * Breakpoint #1 Registers and Control
 * Breakpoint #2..n Control
 * ----------
 * This holds the registers and control for the 1st breakpoint. It provides
 * the ability to break on any one of the six different memory and port (I/O)
 * operations (plus disabled), checking for a 16-bit or 8-bit address (or any),
 * and checking for a specific data value with optional don't-care bits.
 *
 * It also holds the control for the 2nd-nth breakpoint. The control identifies
 * which of the six different memory or port operations should be checked (plus
 * disabled). The 2nd-nth breakpoint address logic is external, with 'break 
 * address match' coming from an input pin.
 *
 * The PINNODE and Defines section has some more information about the
 * breakpoints.
 */

/* Configure cupl */
PROPERTY Atmel {security = OFF};
PROPERTY Atmel {power_reset = ON};
Property Atmel {preassign = TRY};

/* Convenience Names */
$DEFINE ON 'b'1
$DEFINE OFF 'b'0


/************************************************************************/
/* Special Inputs                                                       */
/************************************************************************/

PIN 87 = cpu_clk;           /* Processor CLK (on GCLK1) */
PIN 89 = !cpu_rst;          /* CPU Reset Input */


/************************************************************************/
/* Inputs                                                               */
/************************************************************************/

PIN [85..83,81..79,76,75,71,69..67,65..63,61] = [addr15..0];       /* Address inputs */
PIN     = !rd;
PIN     = !wr;
PIN     = !iorq;
PIN     = !m1;
PIN     = !mreq;
PIN     = !rfsh;
PIN     = !tnmi;        /* Target System NMI request */
PIN     = !tgt_only;    /* Indicates that the Target System should run immediately */
PIN     = tgo_now;      /* Target-Go counter has reached terminal count */
PIN     = attn;         /* Request from RP2040 Module for attention */
/* */
PIN     = b2n_a_eq;      /* Breakpoint 2..n Address match


/************************************************************************/
/* Input/Output                                                         */
/************************************************************************/

PIN [100..96,94..92] = [d7..5,d4..0];   /* Data I/O */


/************************************************************************/
/* Outputs                                                              */
/************************************************************************/

PIN     = !zrst;            /* Reset signal to the Z80 */
PIN [37..35] = [rra2..0];   /* ROM/RAM Address: Actually RRA16..14 on bus */
PIN 14  = !ram_sel;
PIN 13  = !rom_sel;
PIN 12  = !wait;
PROPERTY Atmel {open_collector = on wait};
PIN     = mod_sel;          /* RP2040 Module Select */
PIN     = ba2n_clk;         /* Break Address Clock */
PIN     = ba2nen_clk;       /* Break Address Enable Clock (WR) */
PIN     = ba2nen_rd;        /*  (same addr) Enable Read */
PIN     = ba2nen_clr;       /* Break Address Enable Clear */ 
/*PIN     = extern_io;        /* Signal indicating external I/O operation */
PIN     = !tbus_en;         /* Target Bus Enable */
PIN     = !lnmi;            /* Local NMI */
PIN     = tgt_go;           /* Start the bus operation countdown */
PIN     = brk_det;          /* Break condition detected - SYNC signal on board */


/************************************************************************/
/* Internal Nodes, Registers and Intermediate Variable Definitions      */
/************************************************************************/

/** Z80 Special Reset */
PINNODE = zsr_req;          /* Request to generate a Z80 Special Reset */
PINNODE = zsprst;


/** Boot/Reboot Reset */
PINNODE = iRst;             /* Internal Reset */
PINNODE = [rstCnt1..0];     /* Reset duration counters */


/** MMU */
PINNODE = [mapA3..0];
PINNODE = [mapB3..0];
PINNODE = [mapC3..0];
PINNODE = [mapD4..0];


/** DBI Detect */
PINNODE = dbi;              /* Double-Byte Instruction Detected */


/** Target run and enable state */
PINNODE = sbcmode;          /* We are running as an SBC */
PINNODE = tgtmode;          /* Running target (not in debug mode) */


/**
 * Breakpoint Operations #1 and #2
 * Breakpoint #1 address, data, and mask
 * Breakpoint 2..n address compare is external and is optional
 *
 * Breakpoint operations:
 *  0: None
 *  1: Instruction Fetch (IF)
 *  2: Memory Write (MW)
 *  3: Memory Read (MR)
 *  4: Any Memory operation (AM)
 *  5: Port (I/O) Write (PW)
 *  6: Port (I/O) Read (PR)
 *  7: Any Port (I/O) operation (AP)
 */
PINNODE = [b1op2..0];       /* Breakpoint1 Operation */
PINNODE = [b2op2..0];       /* Breakpoint2..n Operation */
PINNODE = [b1ah7..0];       /* Upper address for BRK1 */
PINNODE = [b1al7..0];       /* Lower address for BRK1 */
PINNODE = [b1d7..0];        /* Data for BRK1 */
PINNODE = [b1dm7..0];       /* Data Mask for BRK1 (these are the bits we care about) */
PINNODE = b1u_ah;           /* Use upper address in breakpoint */
PINNODE = b1u_al;           /* Use lower address in breakpoint */
PINNODE = b1u_d;            /* Use data in breakpoint (written using CTRL1) */
PINNODE = sync_only;        /* Break Detect should only provide SYNC, not stop target */
PINNODE = softbrk_en;       /* Enable detecting soft breakpoint (rst38) */
PINNODE = sngl_op;          /* Enable the target bus for a single bus operation */
                            /*  used for doing target memory-port read-write     */

/** Breakpoint detection and PC storage */
PINNODE = rst38det;         /* Used for 'SOFT' breakpoints          */
PINNODE = b1_det;           /* Breakpoint #1 condition detected     */
PINNODE = b1_a_eq;          /*  address equal                       */
PINNODE = b1_ah_eq;         /*   address high equal (or don't care) */
PINNODE = b1_al_eq;         /*   address low equal (or don't care)  */
PINNODE = b1_d_eq;          /*  data equal                          */
PINNODE = b1_dA_eq;         /*   data NibbleA equal                 */
PINNODE = b1_dB_eq;         /*   data NibbleB equal                 */
PINNODE = b2_det;           /* Breakpoint #2 condition detected     */
PINNODE = [pc15..0];        /* Storage of the PC at Special Reset   */


/************************************************************************/
/* Fields and Convenience/Clarity Definitions                           */
/*                                                                      */
/* NOTE: $DEFINE value cannot use a prior $DEFINE.                      */
/*   Learned through lots of time spent tracking down compile errors!   */
/*   Telltale error is:                                                 */
/*     [0018ca] intermediate var not assigned an expression: xyz        */
/*                                                                      */
/*   Of course, that error could also, legitimately, mean that it       */
/*   hasn't been assigned, but if you get it, and you believe you've    */
/*   assigned it, look for a case of a $DEFINE that contains a $DEFINE. */
/*                                                                      */
/************************************************************************/

/** Z80 General */
$DEFINE ZIF_1       ((m1 & mreq) & !dbi)
$DEFINE MEM_SEL     ((m1 & !iorq) # (mreq & !rfsh))
$DEFINE MEM_WR      (((m1 & !iorq) # (mreq & !rfsh)) & wr)
$DEFINE MEM_RD      (((m1 & !iorq) # (mreq & !rfsh)) & rd)
$DEFINE PORT_SEL      (!m1 & iorq)
$DEFINE PORT_WR       ((!m1 & iorq) & wr)
$DEFINE PORT_RD       ((!m1 & iorq) & rd)
$DEFINE ZNOP        'h'00
$DEFINE ZRFSH       (mreq & rfsh)
FIELD databus       = [d7..0];
FIELD fulladdr      = [addr15..0];

/** I/O Port Decode */
FIELD ioaddr        = [addr7..0];

/** Board and Breakpoint Control */
$DEFINE BRKOP_SEL   ((!m1 & iorq) & ioaddr:['b'0000000x])
$DEFINE B1DV_SEL    ((!m1 & iorq) & ioaddr:['b'0000001x])   /* BRK1 Data Value */
$DEFINE B1DM_SEL    ((!m1 & iorq) & ioaddr:['b'0000001x])   /* BRK1 Data Mask  */
$DEFINE B1AL_SEL    ((!m1 & iorq) & ioaddr:['b'0000010x])   /* BRK1 Addr Low   */
$DEFINE B1AH_SEL    ((!m1 & iorq) & ioaddr:['b'0000011x])   /* BRK1 Addr High  */
$DEFINE CTRL1_SEL   ((!m1 & iorq) & ioaddr:['b'00001xxx])
$DEFINE B1_OP_DATA  [d2..0]     /* BP1 Operation (Break Operation (0)) */
$DEFINE B2_OP_DATA  [d5..3]     /* BP2 Operation (Break Operation (0)) */
$DEFINE B1_USEAL_B  d6          /* BP1 Use Address Low (Break Operation (0)) */
$DEFINE B1_USEAH_B  d7          /* BP1 Use Address High (Break Operation (0)) */
/* */
$DEFINE B1_USEDATA_B    d0      /* Use Data (Board Control 1) */
$DEFINE SOFTBRKEN_B     d1      /* Soft-Break Enable (Board Control 1) */
$DEFINE SNGLOP_B        d2      /* Do a single bus operation (Board Control 1) */
$DEFINE SBCMODE_B       d3      /* Single-Board-Computer mode (Board Control 1) */
$DEFINE SYNCONLY_B      d4      /* Generate a SYNC signal, but don't break (Board Control 1) */


/** MMU */
$DEFINE MMU_SEL     ((!m1 & iorq) & ioaddr:[10..1F])
$DEFINE MMAP_RD     (((!m1 & iorq) & ioaddr:[10..1F]) & rd)
$DEFINE MMAP_WR     (((!m1 & iorq) & ioaddr:[10..1F]) & wr)
$DEFINE MAPADDR_A   [addr15..14]:0
$DEFINE MAPADDR_B   [addr15..14]:1
$DEFINE MAPADDR_C   [addr15..14]:2
$DEFINE MAPADDR_D   [addr15..14]:3

FIELD mapAdata  = ['b'0, 'b'0, 'b'0, 'b'0, mapA3..0];   /* MMap A Data */
FIELD mapBdata  = ['b'0, 'b'0, 'b'0, 'b'0, mapA3..0];   /* MMap B Data */
FIELD mapCdata  = ['b'0, 'b'0, 'b'0, 'b'0, mapA3..0];   /* MMap C Data */
FIELD mapDdata  = ['b'0, 'b'0, 'b'0, mapD4..0];         /* MMap D Data */  

/** DBI Detect */
$DEFINE DBI1_A  'h'CB   /* - CB nn (extended logical operations) */
$DEFINE DBI1_B  'h'DD   /* - DD nn (IX operations) */
$DEFINE DBI1_C  'h'ED   /* - ED nn (extended Z80 operations (16-bit, Interrupt, Memory/IO, etc.)) */
$DEFINE DBI1_D  'h'FD   /* - FD nn (IY operations) */

/** Breakpoint control, detection, and handling */
FIELD b1addrh   = [b1ah7..0];
FIELD b1addrl   = [b1al7..0];
FIELD b1data    = [b1d7..0];
FIELD b1dmask   = [b1dm7..0];
$DEFINE B1OP_NONE   [b1op2..0]:0
$DEFINE B1OP_IF     [b1op2..0]:1
$DEFINE B1OP_MW     [b1op2..0]:2
$DEFINE B1OP_MR     [b1op2..0]:3
$DEFINE B1OP_AM     [b1op2..0]:4
$DEFINE B1OP_PW     [b1op2..0]:5
$DEFINE B1OP_PR     [b1op2..0]:6
$DEFINE B1OP_AP     [b1op2..0]:7
$DEFINE B2OP_NONE   [b2op2..0]:0
$DEFINE B2OP_IF     [b2op2..0]:1
$DEFINE B2OP_MW     [b2op2..0]:2
$DEFINE B2OP_MR     [b2op2..0]:3
$DEFINE B2OP_AM     [b2op2..0]:4
$DEFINE B2OP_PW     [b2op2..0]:5
$DEFINE B2OP_PR     [b2op2..0]:6
$DEFINE B2OP_AP     [b2op2..0]:7
$DEFINE PC_RD   (((!m1 & iorq) & ioaddr:[10..1F]) & ioaddr:['b'0010XXXX])    /* Port 2X */
$DEFINE PC_L_RD (((!m1 & iorq) & ioaddr:[10..1F]) & ioaddr:['b'0010XXX0])    /* Port 20 (plus) */
$DEFINE PC_H_RD (((!m1 & iorq) & ioaddr:[10..1F]) & ioaddr:['b'0010XXX1])    /* Port 21 (plus) */
$DEFINE NOP_FORCE   (zsr_req & ((m1 & mreq) & !dbi))
FIELD pcsaved = [pc15..0];
FIELD pcsaved_l = [pc7..0];
FIELD pcsaved_h = [pc15..8];


/************************************************************************/
/* Logic                                                                */
/************************************************************************/

/** Boot/Reboot Reset */
[rstCnt1..0].ar = !cpu_rst;
[rstCnt1..0].ck = cpu_clk;
[rstCnt1..0].ce = 'b'11;
rstCnt0.t       = cpu_rst;
rstCnt1.t       = cpu_rst & rstCnt0;

iRst.ar     =  iRst & !cpu_rst;
iRst.ap     =  OFF;
iRst.d      =  ON;
iRst.ck     =  rstCnt1 & rstCnt0;
iRst.ce     =  ON;


/** Z80 Special-Reset generation and Z80 Reset signal */
zrst        = cpu_rst # zsprst; /* Reset to the local Z80 is the board reset or the special reset */
zsr_req.ck  = attn & tgtmode    /* Running the target and the RP2040 Module wants attention */
            # brk_det;          /* Break condition detected */
zsr_req.d   = ON;
zsr_req.ar  = zrst;
/* Special Reset: must be true on rising edge of M1-T2 only (see patent) */
zsprst.d    = zsr_req;
zsprst.ck   = !zsprst & ZIF_1   /* Accept request at beginning of IF1 */
            # zsprst & cpu_clk; /* Clear Special Reset with rising edge of CLK */


/** Local Z80 NMI request generation */
lnmi        = tgtmode & tnmi    /* Target running and it has an NMI (don't allow target NMI in Debug Mode) */
            # !tgtmode & attn;  /* In Debug Mode (not running the target) and RP Module wants attention */


/** MMU Register Set/Write */
[mapA3..0].ap =  [d3..0] & MAPADDR_A & MMAP_WR;
[mapA3..0].ar = ![d3..0] & MAPADDR_A & MMAP_WR;
[mapA3..0].d = ['b'0000];
[mapA3..0].ck = !iRst;
[mapB3..0].ap =  [d3..0] & MAPADDR_B & MMAP_WR;
[mapB3..0].ar = ![d3..0] & MAPADDR_B & MMAP_WR;
[mapB3..0].d = ['b'0001];
[mapB3..0].ck = !iRst;
[mapC3..0].ap =  [d3..0] & MAPADDR_C & MMAP_WR;
[mapC3..0].ar = ![d3..0] & MAPADDR_C & MMAP_WR;
[mapC3..0].d = ['b'0010];
[mapC3..0].ck = !iRst;
[mapD4..0].ap =  [d4..0] & MAPADDR_D & MMAP_WR;
[mapD4..0].ar = ![d4..0] & MAPADDR_D & MMAP_WR;
[mapD4..0].d = ['b'0011];
[mapD4..0].ck = !iRst;

/** MMU RR-Address and ROM/RAM Select Logic */
[rra2..0] = [d2..0];
rom_sel     = MEM_SEL & rd & !d3;
ram_sel     = MEM_SEL & wr
            # MEM_SEL & rd & d3;

/** MMU Wait-State Generation - 1 WS for ROM Reads */
wait.ck = (m1 & !iorq) # (mreq & !rfsh);
wait.d  = !wait;
wait.ar = ram_sel;


/** I/O Port Decode */
tgt_go      = PORT_SEL & ioaddr:[30..3F];
mod_sel     = PORT_SEL & ioaddr:[40..4F];
ba2n_clk    = PORT_SEL & ioaddr:[50..5F];
ba2nen_clk  = PORT_SEL & ioaddr:[60..6F] & wr;
ba2nen_rd   = PORT_SEL & ioaddr:[60..6F] & rd;
ba2nen_clr  = PORT_SEL & ioaddr:[70..7F];
/*extern_io   = PORT_SEL & ioaddr:[80..FF]; /* For use by external devices */


/** SBC Mode, Target Mode, and Bus Control */
sbcmode.d   = SBCMODE_B;
sbcmode.ck  = CTRL1_SEL;
sbcmode.ar  = iRst;
tgtmode.ck  = tgo_now;
tgtmode.d   = ON;
tgtmode.ar  = zrst;             /* Target Mode is cleared by either a Special or Full Reset */
/* */
tbus_en = tgtmode & !sbcmode;   /* Enable the Target Bus in Target Mode unless running as SBC */


/** Breakpoint Registers and Control */
[b1op2..0].d    = B1_OP_DATA;        /* Breakpoint1 Operation */
[b1op2..0].ck   = BRKOP_SEL;
[b1op2..0].ar   = iRst;
[b2op2..0].d    = B2_OP_DATA;        /* Breakpoint2 Operation */
[b2op2..0].ck   = BRKOP_SEL;
[b2op2..0].ar   = iRst;
[b1ah7..0].d    = databus;      /* Breakpoint1 Address High */
[b1ah7..0].ck   = B1AH_SEL;
[b1ah7..0].ar   = iRst;
[b1al7..0].d    = databus;      /* Breakpoint1 Address Low */
[b1al7..0].ck   = B1AL_SEL;
[b1al7..0].ar   = iRst;
[b1d7..0].d     = databus;      /* Breakpoint1 Data */
[b1d7..0].ck    = B1DV_SEL;
[b1d7..0].ar    = iRst;
[b1dm7..0].d    = databus;      /* Breakpoint1 Data Mask */
[b1dm7..0].ck   = B1DM_SEL;
[b1dm7..0].ar   = iRst;
b1u_ah.d        = B1_USEAH_B;   /* Use Upper address in breakpoint */
b1u_ah.ck       = BRKOP_SEL;
b1u_ah.ar       = iRst;
b1u_al.d        = B1_USEAL_B;   /* Use lower address in breakpoint */
b1u_al.ck       = BRKOP_SEL;
b1u_al.ar       = iRst;
b1u_d.d         = B1_USEDATA_B; /* Use data in breakpoint (written using CTRL1) */
b1u_d.ck        = CTRL1_SEL;
b1u_d.ar        = iRst;
/* */
softbrk_en.d    = SOFTBRKEN_B;
softbrk_en.ck   = CTRL1_SEL;
softbrk_en.ar   = iRst;
/* */
sync_only.d     = SYNCONLY_B;
sync_only.ck    = CTRL1_SEL;
sync_only.ar    = iRst;
/* */
sngl_op.d       = SNGLOP_B;
sngl_op.ck      = CTRL1_SEL;
sngl_op.ar      = iRst;


/** DBI Detect */
dbi.d   = !dbi & (DBI1_A # DBI1_B # DBI1_C # DBI1_D);
dbi.ck  = cpu_clk;
dbi.ce  = (m1 & mreq);


/** RST38 Detect */
rst38det.d  = databus:'h'FF;
rst38det.ck = cpu_clk;
rst38det.ce = ZIF_1;
rst38det.ar = ZRFSH;
rst38det.ap = OFF;


/** Breakpoint Detection, PC Capture (NOP Force is in the Data Bus section) */
b1_ah_eq    = 
            (!b1u_ah
              # (b1u_ah
                & !(b1ah7 $ addr15) 
                & !(b1ah6 & addr14)
                & !(b1ah5 & addr13)
                & !(b1ah4 & addr12)
                & !(b1ah3 & addr11)
                & !(b1ah2 & addr10)
                & !(b1ah1 & addr9)
                & !(b1ah0 & addr8)
                )
            );
b1_al_eq    =
            (!b1u_al
              # (b1u_al
                & !(b1al7 $ addr7) 
                & !(b1al6 $ addr6)
                & !(b1al5 $ addr5)
                & !(b1al4 $ addr4)
                & !(b1al3 $ addr3)
                & !(b1al2 $ addr2)
                & !(b1al1 $ addr1)
                & !(b1al0 $ addr0)
                )
            );
b1_a_eq     = b1_ah_eq & b1_al_eq;

/* 
 Had to break Data into 2 nibbles to keep CUPL from crashing.
 Specifically CUPLc getting a file read error due to CUPLn not
 finishing correctly.
*/
b1_dA_eq     = (!b1dm7 # !(b1d7 $ d7))
             & (!b1dm6 # !(b1d7 $ d6))
             & (!b1dm5 # !(b1d5 $ d5))
             & (!b1dm4 # !(b1d4 $ d4));
b1_dB_eq     = (!b1dm3 # !(b1d3 $ d3))
             & (!b1dm2 # !(b1d2 $ d2))
             & (!b1dm1 # !(b1d1 $ d1))
             & (!b1dm0 # !(b1d0 $ d0));
b1_d_eq     = !b1u_d # (b1_dA_eq & b1_dB_eq);

b1_det      =  (B1OP_IF & ZIF_1 & b1_a_eq)
             # (B1OP_MW & MEM_WR & b1_a_eq & b1_d_eq)
             # (B1OP_MR & MEM_RD & b1_a_eq & !b1u_d # b1_d_eq)
             # (B1OP_AM & MEM_SEL & b1_a_eq & !b1u_d # b1_d_eq)
             # (B1OP_PW & PORT_WR & b1_a_eq & !b1u_d # b1_d_eq)
             # (B1OP_PR & PORT_RD & b1_a_eq & !b1u_d # b1_d_eq)
             # (B1OP_AP & PORT_SEL & b1_a_eq & !b1u_d # b1_d_eq);

b2_det      =  (B2OP_IF & ZIF_1 & b2n_a_eq)
             # (B2OP_MW & MEM_WR & b2n_a_eq)
             # (B2OP_MR & MEM_RD & b2n_a_eq)
             # (B2OP_AM & MEM_SEL & b2n_a_eq)
             # (B2OP_PW & PORT_WR & b2n_a_eq)
             # (B2OP_PR & PORT_RD & b2n_a_eq)
             # (B2OP_AP & PORT_SEL & b2n_a_eq);

brk_det     =  (softbrk_en & rst38det)
             # b1_det
             # b2_det;
/* */
pcsaved.d   = fulladdr;
pcsaved.ck  = cpu_clk;
pcsaved.ce  = m1 & tgtmode;


/** Data Bus takes values from multiple things, so they all need to be here */
/*  MMU Register Read, PC Read, or Z80 NOP Force */
databus     = (MMAP_RD & mapAdata & MAPADDR_A)  /* Reading the Memory Map Reg */
            # (MMAP_RD & mapBdata & MAPADDR_B)
            # (MMAP_RD & mapCdata & MAPADDR_C)
            # (MMAP_RD & mapDdata & MAPADDR_D)
            # (NOP_FORCE & ZNOP)                /* Force NOP during Special Reset */
            # (PC_L_RD & pcsaved_l)             /* Reading the saved PC */
            # (PC_H_RD & pcsaved_h);
databus.oe  = MMAP_RD # NOP_FORCE # PC_RD;      /* Onto the Data Bus for any of those */
